---
description: Enforce strict TypeScript typing conventions
globs: **/*.{ts,tsx}
---
- **`any` est INTERDIT**, sauf justification explicite et commentée.
- Activer TOUTES les options de strict mode dans `tsconfig.json`.
- Définir des interfaces explicites pour TOUS les composants, objets de données et payloads.
- Typer explicitement les arguments et les valeurs de retour de TOUTES les fonctions.
- Utiliser les génériques pour la réutilisabilité et la sécurité des types.
- Gérer TOUTES les erreurs potentielles avec `try...catch` et des assertions de type.
- Utiliser les types utilitaires de TypeScript (`ReturnType`, `Omit`, `Pick`, `Partial`, etc.) lorsque c'est approprié.
- Utiliser des unions discriminées pour la vérification d'exhaustivité.
- Documenter les interfaces et les types complexes avec des commentaires JSDoc.
- Exemple de composant avec props typées :
  ```typescript
  interface MyComponentProps {
    title: string;
    count: number;
    onClick: (id: string) => void;
  }

  const MyComponent: React.FC<MyComponentProps> = ({ title, count, onClick }) => { ... };
  ```
- Exemple de Server Action typée :
  ```typescript
  // src/app/actions.ts
  'use server';

  import { z } from 'zod';
  import { db } from '@/lib/db';

  const schema = z.object({
    id: z.string(),
    name: z.string().min(3),
  });

  type InputType = z.infer<typeof schema>;

  export async function updateItem(input: InputType) {
    try {
      const validatedData = schema.parse(input);
      await db.item.update({
        where: { id: validatedData.id },
        data: { name: validatedData.name },
      });
      return { success: true };
    } catch (error) {
      return { success: false, error: 'Failed to update item.' };
    }
  }
  ``` 